Homework 1
================
Julia Thompson
9/13/2019

## Problem 0.1

This is a very simple R Markdown document for problem 0.1 just to get
set up.

## Problem 1

Below is code to create a simple data frame containing the following:

  - a random sample of size 8 from a standard Normal distribution

  - a logical vector indicating whether elements of the sample are
    greater than 0

  - a character vector of length 8

  - a factor vector of length 8, with 3 different factor “levels”

<!-- end list -->

``` r
simple_df1 = tibble(
  sample_norm = rnorm(8),
  gr_th_0 = sample_norm > 0,
  vec_char = c("One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight"),
  vec_factor = factor(c("male", "male", "other", "female", "male", "male", "female", "other")) 
)
```

If I attempt to take the mean of each variable in the dataframe, we
obtain values for the numeric and logical variables, but see an error
for the character and factor
    variables.

``` r
mean(pull(simple_df1, sample_norm))
```

    ## [1] -0.4171493

``` r
mean(pull(simple_df1, gr_th_0))
```

    ## [1] 0.375

``` r
mean(pull(simple_df1, vec_char))
```

    ## Warning in mean.default(pull(simple_df1, vec_char)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(pull(simple_df1, vec_factor))
```

    ## Warning in mean.default(pull(simple_df1, vec_factor)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

The below code chunk applies the *as.numeric* function to the logical,
character, and factor variables. We see that both logical and factor
variables can be converted to numeric, though the mean of a logical
variable can be taken without conversion. Character variables are unable
to be converted to numeric this way, and we are still unable to take the
mean. When we use the *as.numeric* function on the factor variable, each
element assumes the value of it’s level, which is not particularly
helpful for analysis in most cases. This shows that, even though I have
typed numbers in my character variable, R does not understand the
meaning and cannot evaluate them.

``` r
mean(as.numeric(pull(simple_df1, gr_th_0)))
mean(as.numeric(pull(simple_df1, vec_char))) #this gives a warning and does not take the mean
mean(as.numeric(pull(simple_df1, vec_factor)))
```

In a second code chunk:

  - convert the logical vector to numeric, and multiply the random
    sample by the result

  - convert the logical vector to a factor, and multiply the random
    sample by the result

  - convert the logical vector to a factor and then convert the result
    to numeric, and multiply the random sample by the result

We see a key difference in logical versus numeric versus facor
variables. Logical to numeric converts *true* to 1 and *false* to 0.
However, logical to factor converts *true* to 1 and *false* to 2.

``` r
log_to_num = as.numeric(pull(simple_df1, gr_th_0))
rs_x_log_to_num = log_to_num * pull(simple_df1, sample_norm)

log_to_fac = as.factor(pull(simple_df1, gr_th_0))
rs_x_log_to_fac = log_to_fac * pull(simple_df1, sample_norm) # Factor variables are categorical, so this won't work
```

    ## Warning in Ops.factor(log_to_fac, pull(simple_df1, sample_norm)): '*' not
    ## meaningful for factors

``` r
log_to_fac_to_num = as.numeric(log_to_fac)
rs_x_log_to_fac_to_num = log_to_fac_to_num * pull(simple_df1, sample_norm)

log_to_num
```

    ## [1] 0 0 0 0 1 1 1 0

``` r
log_to_fac
```

    ## [1] FALSE FALSE FALSE FALSE TRUE  TRUE  TRUE  FALSE
    ## Levels: FALSE TRUE

``` r
log_to_fac_to_num
```

    ## [1] 1 1 1 1 2 2 2 1

``` r
rs_x_log_to_num
```

    ## [1] 0.00000000 0.00000000 0.00000000 0.00000000 0.89391414 0.32111105
    ## [7] 0.02240654 0.00000000

``` r
rs_x_log_to_fac_to_num
```

    ## [1] -1.39651320 -0.08277421 -1.52140019 -0.86809724  1.78782828  0.64222209
    ## [7]  0.04481308 -0.70584126

## Problem 2

Create a data frame comprised of: x: a random sample of size 500 from a
standard Normal distribution y: a random sample of size 500 from a
standard Normal distribution A logical vector indicating whether x + y
\> 1 A numeric vector created by coercing the above logical vector A
factor vector created by coercing the above logical vector

``` r
simple_df2 = tibble(
  x = rnorm(500),
  y = rnorm(500),
  gr_th_1 = x + y > 1,
  log_num = as.numeric(gr_th_1),
  log_fac = as.factor(gr_th_1)
)
```

The above dataframe contains 5 variables *(x, y, gr\_th\_1, log\_num,
log\_fac)* of 500 observations each. X and y are both normally
distributed variables. X has a mean of 0.0346277, median of 0.0546351,
and standard deviation of 0.9615349. The variable *gr\_th\_1* represents
whether x + y is greater than 1. There are 120/500 cases where x + y is
greater than 1.

Make a scatterplot of y vs x; color points using the logical variable
(adding color = … inside of aes in your ggplot code should help). Make a
second and third scatterplot that color points using the numeric and
factor variables, respectively, and comment on the color scales.

``` r
ggplot(simple_df2, aes(x = x, y = y, color=gr_th_1)) + geom_point()
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-1.png)<!-- -->

``` r
ggplot(simple_df2, aes(x = x, y = y, color=log_num)) + geom_point()
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-2.png)<!-- -->

``` r
ggplot(simple_df2, aes(x = x, y = y, color=log_fac)) + geom_point()
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-3.png)<!-- -->
