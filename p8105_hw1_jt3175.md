Homework 1
================
Julia Thompson
9/13/2019

## Problem 0.1

This is a very simple R Markdown document for problem 0.1 just to get
set up.

## Problem 1

Below is code to create a simple data frame containing the following:

  - a random sample of size 8 from a standard Normal distribution

  - a logical vector indicating whether elements of the sample are
    greater than 0

  - a character vector of length 8

  - a factor vector of length 8, with 3 different factor “levels”

<!-- end list -->

``` r
simple_df = tibble(
  sample_norm = rnorm(8),
  gr_th_0 = sample_norm > 0,
  vec_char = c("One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight"),
  vec_factor = factor(c("male", "male", "other", "female", "male", "male", "female", "other")) 
)
```

If I attempt to take the mean of each variable in the dataframe, we
obtain values for the numeric and logical variables, but see an error
for the character and factor
    variables.

``` r
mean(pull(simple_df, sample_norm))
```

    ## [1] 0.285474

``` r
mean(pull(simple_df, gr_th_0))
```

    ## [1] 0.5

``` r
mean(pull(simple_df, vec_char))
```

    ## Warning in mean.default(pull(simple_df, vec_char)): argument is not numeric
    ## or logical: returning NA

    ## [1] NA

``` r
mean(pull(simple_df, vec_factor))
```

    ## Warning in mean.default(pull(simple_df, vec_factor)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

The below code chunk applies the *as.numeric* function to the logical,
character, and factor variables. We see that both logical and factor
variables can be converted to numeric, though the mean of a logical
variable can be taken without conversion. Character variables are unable
to be converted to numeric this way, and we are still unable to take the
mean. When we use the *as.numeric* function on the factor variable, each
element assumes the value of it’s level, which is not particularly
helpful for analysis in most cases. This shows that, even though I have
typed numbers in my character variable, R does not understand the
meaning and cannot evaluate them.

``` r
mean(as.numeric(pull(simple_df, gr_th_0)))
mean(as.numeric(pull(simple_df, vec_char))) #this gives a warning and does not take the mean
mean(as.numeric(pull(simple_df, vec_factor)))
```

In a second code chunk:

  - convert the logical vector to numeric, and multiply the random
    sample by the result

  - convert the logical vector to a factor, and multiply the random
    sample by the result

  - convert the logical vector to a factor and then convert the result
    to numeric, and multiply the random sample by the result

We see a key difference in logical versus numeric versus facor
variables. Logical to numeric converts *true* to 1 and *false* to 0.
However, logical to factor converts *true* to 1 and *false* to 2.

``` r
log_to_num = as.numeric(pull(simple_df, gr_th_0))
rs_x_log_to_num = log_to_num * pull(simple_df, sample_norm)

log_to_fac = as.factor(pull(simple_df, gr_th_0))
rs_x_log_to_fac = log_to_fac * pull(simple_df, sample_norm) # Factor variables are categorical, so this won't work
```

    ## Warning in Ops.factor(log_to_fac, pull(simple_df, sample_norm)): '*' not
    ## meaningful for factors

``` r
log_to_fac_to_num = as.numeric(log_to_fac)
rs_x_log_to_fac_to_num = log_to_fac_to_num * pull(simple_df, sample_norm)

log_to_num
```

    ## [1] 1 1 0 1 0 0 1 0

``` r
log_to_fac
```

    ## [1] TRUE  TRUE  FALSE TRUE  FALSE FALSE TRUE  FALSE
    ## Levels: FALSE TRUE

``` r
log_to_fac_to_num
```

    ## [1] 2 2 1 2 1 1 2 1

``` r
rs_x_log_to_num
```

    ## [1] 1.2184113 0.7947034 0.0000000 0.3628740 0.0000000 0.0000000 1.4585899
    ## [8] 0.0000000

``` r
rs_x_log_to_fac_to_num
```

    ## [1]  2.4368226  1.5894069 -0.4558927  0.7257480 -0.1602113 -0.6101100
    ## [7]  2.9171797 -0.3245730
