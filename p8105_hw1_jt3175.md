Homework 1
================
Julia Thompson
9/13/2019

## Problem 0.1

This is a very simple R Markdown document for problem 0.1 just to get
set up.

## Problem 1

Below is code to create a simple data frame containing the following:

  - a random sample of size 8 from a standard Normal distribution

  - a logical vector indicating whether elements of the sample are
    greater than 0

  - a character vector of length 8

  - a factor vector of length 8, with 3 different factor “levels”

<!-- end list -->

``` r
simple_df1 = tibble(
  sample_norm = rnorm(8),
  gr_th_0 = sample_norm > 0,
  vec_char = c("One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight"),
  vec_factor = factor(c("male", "male", "other", "female", "male", "male", "female", "other")) 
)
```

If I attempt to take the mean of each variable in the dataframe, we
obtain values for the numeric and logical variables, but see an error
for the character and factor
    variables.

``` r
mean(pull(simple_df1, sample_norm))
```

    ## [1] -0.3222651

``` r
mean(pull(simple_df1, gr_th_0))
```

    ## [1] 0.375

``` r
mean(pull(simple_df1, vec_char))
```

    ## Warning in mean.default(pull(simple_df1, vec_char)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

``` r
mean(pull(simple_df1, vec_factor))
```

    ## Warning in mean.default(pull(simple_df1, vec_factor)): argument is not
    ## numeric or logical: returning NA

    ## [1] NA

The below code chunk applies the *as.numeric* function to the logical,
character, and factor variables. We see that both logical and factor
variables can be converted to numeric, though the mean of a logical
variable can be taken without conversion. Character variables are unable
to be converted to numeric this way, and we are still unable to take the
mean. When we use the *as.numeric* function on the factor variable, each
element assumes the value of it’s level, which is not particularly
helpful for analysis in most cases. This shows that, even though I have
typed numbers in my character variable, R does not understand the
meaning and cannot evaluate them.

``` r
as.numeric(pull(simple_df1, gr_th_0))
as.numeric(pull(simple_df1, vec_char)) #this gives a warning
as.numeric(pull(simple_df1, vec_factor))
```

The below code chunk tests three different scenarios:

  - Convert the logical vector to numeric, and multiply the random
    sample by the result

  - Convert the logical vector to a factor, and multiply the random
    sample by the result

  - Convert the logical vector to a factor and then convert the result
    to numeric, and multiply the random sample by the result

The second scenario does not work because factor variables are
categorical, so multiplicaiton cannot be performed. We see a key
difference in logical versus numeric versus facor variables. Logical to
numeric converts *true* to 1 and *false* to 0. However, logical to
factor converts *true* to 1 and *false* to 2.

``` r
log_to_num = as.numeric(pull(simple_df1, gr_th_0))
rs_x_log_to_num = log_to_num * pull(simple_df1, sample_norm)

log_to_fac = as.factor(pull(simple_df1, gr_th_0))
rs_x_log_to_fac = log_to_fac * pull(simple_df1, sample_norm) # Factor variables are categorical, so this won't work
```

    ## Warning in Ops.factor(log_to_fac, pull(simple_df1, sample_norm)): '*' not
    ## meaningful for factors

``` r
log_to_fac_to_num = as.numeric(log_to_fac)
rs_x_log_to_fac_to_num = log_to_fac_to_num * pull(simple_df1, sample_norm)

log_to_num
```

    ## [1] 0 1 0 0 0 1 0 1

``` r
log_to_fac
```

    ## [1] FALSE TRUE  FALSE FALSE FALSE TRUE  FALSE TRUE 
    ## Levels: FALSE TRUE

``` r
log_to_fac_to_num
```

    ## [1] 1 2 1 1 1 2 1 2

``` r
rs_x_log_to_num
```

    ## [1] 0.0000000 0.2140363 0.0000000 0.0000000 0.0000000 0.1889077 0.0000000
    ## [8] 0.6693869

``` r
rs_x_log_to_fac_to_num
```

    ## [1] -0.04318744  0.42807255 -1.56864110 -0.68353048 -1.26408677  0.37781538
    ## [7] -0.09100600  1.33877378

## Problem 2

``` r
simple_df2 = tibble(
  x = rnorm(500),
  y = rnorm(500),
  gr_th_1 = x + y > 1,
  log_num = as.numeric(gr_th_1),
  log_fac = as.factor(gr_th_1)
)
```

The above dataframe contains 5 variables *(x, y, gr\_th\_1, log\_num,
log\_fac)* of 500 observations each. X and y are both normally
distributed variables. X has a mean of -0.0138174, median of -0.0664378,
and standard deviation of 1.0890077. The variable *gr\_th\_1* represents
whether x + y is greater than 1. There are 127/500 cases where x + y is
greater than 1.

Below are three scatterplots of y vs x. On the first, points are colored
using the logical variable. The second and third scatterplots color
points using the numeric and factor variables, respectively. Both the
logical and factor color scales are binary (producing 2 solid colors).
However, use of the numeric variable for coloring produces a gradient
that ranges over the values (0 to 1), but only 2 colors are displayed in
the scatterplot because we only have 2 values
represented.

``` r
colored_logical = ggplot(simple_df2, aes(x = x, y = y, color=gr_th_1)) + geom_point()
colored_numeric = ggplot(simple_df2, aes(x = x, y = y, color=log_num)) + geom_point()
colored_factor = ggplot(simple_df2, aes(x = x, y = y, color=log_fac)) + geom_point()

colored_logical
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-1.png)<!-- -->

``` r
colored_numeric
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-2.png)<!-- -->

``` r
colored_factor
```

![](p8105_hw1_jt3175_files/figure-gfm/yx_scatter-3.png)<!-- -->

``` r
ggsave("colored_logical.pdf")
```

    ## Saving 7 x 5 in image
